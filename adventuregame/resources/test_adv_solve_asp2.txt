turn_limit(50).
turn(0).
{ turn(TURN+1) } 1 :- turn(TURN), not turn_limit(TURN).
post_turn(TURN+1) :- turn(TURN), not turn(TURN+1).

at_t(0,kitchen1floor1,kitchen1).
at_t(0,pantry1floor1,pantry1).
at_t(0,hallway1floor1,hallway1).
at_t(0,livingroom1floor1,livingroom1).
at_t(0,broomcloset1floor1,broomcloset1).
at_t(0,bedroom1floor1,bedroom1).
at_t(0,table1,livingroom1).
at_t(0,sidetable1,livingroom1).
at_t(0,counter1,kitchen1).
at_t(0,refrigerator1,pantry1).
at_t(0,cupboard1,kitchen1).
at_t(0,wardrobe1,bedroom1).
at_t(0,shelf1,livingroom1).
at_t(0,freezer1,pantry1).
at_t(0,pottedplant1,hallway1).
at_t(0,chair1,livingroom1).
at_t(0,bed1,bedroom1).
at_t(0,couch1,livingroom1).
at_t(0,broom1,broomcloset1).
at_t(0,mop1,broomcloset1).
at_t(0,sandwich1,pantry1).
at_t(0,apple1,pantry1).
at_t(0,banana1,pantry1).
at_t(0,orange1,pantry1).
at_t(0,peach1,pantry1).
at_t(0,plate1,kitchen1).
at_t(0,book1,bedroom1).
at_t(0,pillow1,bedroom1).
at_t(0,player1,bedroom1).
type(kitchen1floor1,floor).
type(pantry1floor1,floor).
type(hallway1floor1,floor).
type(livingroom1floor1,floor).
type(broomcloset1floor1,floor).
type(bedroom1floor1,floor).
type(player1,player).
type(table1,table).
type(sidetable1,sidetable).
type(counter1,counter).
type(refrigerator1,refrigerator).
type(cupboard1,cupboard).
type(wardrobe1,wardrobe).
type(shelf1,shelf).
type(freezer1,freezer).
type(pottedplant1,pottedplant).
type(chair1,chair).
type(bed1,bed).
type(couch1,couch).
type(broom1,broom).
type(mop1,mop).
type(sandwich1,sandwich).
type(apple1,apple).
type(banana1,banana).
type(orange1,orange).
type(peach1,peach).
type(plate1,plate).
type(book1,book).
type(pillow1,pillow).
room(kitchen1,kitchen).
room(pantry1,pantry).
room(hallway1,hallway).
room(livingroom1,livingroom).
room(broomcloset1,broomcloset).
room(bedroom1,bedroom).
support(kitchen1floor1).
support(pantry1floor1).
support(hallway1floor1).
support(livingroom1floor1).
support(broomcloset1floor1).
support(bedroom1floor1).
support(table1).
support(sidetable1).
support(counter1).
support(shelf1).
support(chair1).
support(bed1).
support(couch1).
on_t(0,pillow1,bed1).
on_t(0,book1,bedroom1floor1).
on_t(0,plate1,kitchen1floor1).
on_t(0,mop1,broomcloset1floor1).
on_t(0,broom1,broomcloset1floor1).
on_t(0,pottedplant1,hallway1floor1).
container(refrigerator1).
container(cupboard1).
container(wardrobe1).
container(freezer1).
in_t(0,peach1,refrigerator1).
in_t(0,orange1,refrigerator1).
in_t(0,banana1,refrigerator1).
in_t(0,apple1,refrigerator1).
in_t(0,sandwich1,refrigerator1).
exit(kitchen1,pantry1).
exit(kitchen1,livingroom1).
exit(kitchen1,hallway1).
exit(pantry1,kitchen1).
exit(hallway1,kitchen1).
exit(hallway1,broomcloset1).
exit(livingroom1,kitchen1).
exit(broomcloset1,hallway1).
exit(bedroom1,hallway1).
exit(hallway1,bedroom1).
openable(refrigerator1).
openable(cupboard1).
openable(wardrobe1).
openable(freezer1).
closed_t(0,refrigerator1).
closed_t(0,cupboard1).
closed_t(0,wardrobe1).
closed_t(0,freezer1).
takeable(pottedplant1).
takeable(broom1).
takeable(mop1).
takeable(sandwich1).
takeable(apple1).
takeable(banana1).
takeable(orange1).
takeable(peach1).
takeable(plate1).
takeable(book1).
takeable(pillow1).
movable(pottedplant1).
movable(broom1).
movable(mop1).
movable(sandwich1).
movable(apple1).
movable(banana1).
movable(orange1).
movable(peach1).
movable(plate1).
movable(book1).
movable(pillow1).
needs_support(pottedplant1).
needs_support(broom1).
needs_support(mop1).
needs_support(sandwich1).
needs_support(apple1).
needs_support(banana1).
needs_support(orange1).
needs_support(peach1).
needs_support(plate1).
needs_support(book1).
needs_support(pillow1).
{ action_t(TURN,open,THING):at_t(TURN,THING,ROOM),closed_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).
open_t(TURN+1,THING) :- action_t(TURN,open,THING).
open_t(TURN+1,THING) :- turn(TURN), open_t(TURN,THING), not action_t(TURN,close,THING).
{ action_t(TURN,close,THING):at_t(TURN,THING,ROOM),open_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).
closed_t(TURN+1,THING) :- action_t(TURN,close,THING).
closed_t(TURN+1,THING) :- turn(TURN), closed_t(TURN,THING), not action_t(TURN,open,THING).
{ action_t(TURN,take,THING):at_t(TURN,THING,ROOM),takeable(THING),in_t(TURN,THING,CONTAINER),open_t(TURN,CONTAINER),at_t(TURN,player1,ROOM);action_t(TURN,take,THING):at_t(TURN,THING,ROOM),takeable(THING),on_t(TURN,THING,SUPPORT),support(SUPPORT),at_t(TURN,player1,ROOM) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).
in_t(TURN+1,THING,inventory) :- action_t(TURN,take,THING).
in_t(TURN+1,THING,TARGET) :- turn(TURN), in_t(TURN,THING,TARGET), not action_t(TURN,take,THING), TARGET != inventory.
on_t(TURN+1,THING,TARGET) :- turn(TURN), on_t(TURN,THING,TARGET), not action_t(TURN,take,THING).
{ action_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),open_t(TURN,SOURCE),container(TARGET),open_t(TURN,TARGET);action_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),open_t(TURN,SOURCE),support(TARGET);action_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),support(TARGET),movable(THING),on_t(TURN,THING,SOURCE),support(SOURCE);action_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),movable(THING),in_t(TURN,THING,inventory),container(TARGET),open_t(TURN,TARGET);action_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),movable(THING),in_t(TURN,THING,inventory),support(TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).
in_t(TURN+1,THING,TARGET) :- turn(TURN), action_t(TURN,put,THING,TARGET), container(TARGET).
on_t(TURN+1,THING,TARGET) :- turn(TURN), action_t(TURN,put,THING,TARGET), support(TARGET).
in_t(TURN+1,THING,inventory) :- turn(TURN), in_t(TURN,THING,inventory), not action_t(TURN,put,THING,_).
{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).
at_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).
at_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).
at_t(TURN+1,THING,TARGET) :- action_t(TURN,go,TARGET), in_t(TURN,THING,inventory).
at_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not in_t(TURN,THING,inventory), not turn_limit(TURN), THING != player1.


:- { action_t(TURN,_,_);action_t(TURN,_,_,_) } > 1, turn(TURN).
:- { action_t(TURN,_,_);action_t(TURN,_,_,_) } = 0, turn(TURN).
:- post_turn(POST), not on_t(POST,pillow1,table1).
:- post_turn(POST), not on_t(POST,book1,table1).
:- post_turn(POST), not on_t(POST,plate1,table1).
#minimize{1,X:turn(X)}.
#show action_t/3.
#show action_t/4.