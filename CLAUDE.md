# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

AdventureGame is an Interactive Fiction/Text Adventure game built for the clemgame benchmarking framework. It evaluates language models' ability to understand and navigate text-based adventure games by completing goals through action commands.

The system uses Answer Set Programming (Clingo) to generate adventure instances and optimal solutions, PDDL (Planning Domain Definition Language) for action/domain definitions, and Lark for parsing player commands.

## Core Architecture

### Main Components

1. **Game Master** (`master.py`)
   - `AdventureGameMaster`: Orchestrates game episodes, prompts models, parses responses, and interacts with the IF interpreter
   - `AdventureGameScorer`: Computes metrics from episode records
   - `AdventureGameBenchmark`: Creates game masters and scorers for benchmark runs

2. **IF Interpreter** (`if_wrapper.py`)
   - `AdventureIFInterpreter`: Core interpreter that processes player actions and maintains world state
   - `IFTransformer`: Lark transformer converting parsed actions to Python dicts
   - `PDDLBaseTransformer`: Parses PDDL domain and action definitions

3. **Instance Generator** (`instancegenerator.py`)
   - `AdventureGameInstanceGenerator`: Generates game instances from raw adventures
   - Creates both 'basic' and 'planning' variants from the same adventure pool
   - Handles prompt template substitution and new-word action shuffling

4. **Adventure Generator** (`resources/clingo_adventures2-2.py`)
   - `ClingoAdventureGenerator`: Uses Clingo ASP solver to generate viable initial world states and optimal solutions
   - Loads PDDL definitions for rooms, entities, actions, domains, and events
   - Generates goal sets and validates solvability

### Data Flow

1. Adventure definitions (rooms, entities, actions, domains) → Clingo ASP solver
2. Clingo generates initial world states → Goal generation
3. Combined initial states + goals → Optimal solution generation via Clingo
4. Raw adventures → Instance generator → Game instances with prompts
5. Game instances → Master → IF interpreter → Model interactions → Scoring

### Game Variants

- **basic**: Model provides single action per turn (e.g., `> open cupboard`)
- **plan**: Model provides action + next planned actions (e.g., `> open cupboard\nNext actions: take orange, eat orange`)
- **invlimit**: Variants with inventory capacity limits
- **preexplore**: Variants with pre-exploration sequences

### Adventure Types

Defined in `resources/definitions/adventure_types.json`:
- **home_deliver_three**: Deliver objects to target locations (easy/hard difficulties)
- **potion_brewing**: Potion crafting with special actions (stir, wave, dump)
- **new-words**: Tests novel action understanding (created/replace variants)

## Development Commands

### Running the Framework

The game is designed to run within the clemgame/clembench framework. To run:

```bash
# From the clemgame framework root (not this repo):
python3 scripts/cli.py run -g adventuregame -m <model_name>
```

### Generating Instances

```bash
# From the adventuregame directory:
python3 instancegenerator.py
```

This reads raw adventures from `resources/` and creates instance files in `in/`.

### Generating Adventures

To generate new adventures using Clingo:

```bash
# From the adventuregame/resources directory:
python3 clingo_adventures2-2.py
```

This creates raw adventure JSON files combining initial states, goals, and optimal solutions.

### Evaluation

After running benchmarks, evaluate results using the Jupyter notebooks:

```bash
jupyter notebook adventuregame_eval_2_3.ipynb
```

The notebooks expect a `results/raw.csv` file generated by running `bencheval.py` from the clemgame framework.

## Key Files and Directories

### Instance Files (`in/`)
- `instances.json`: Current production instances
- `instances_*.json`: Various experimental instance sets
- Different variants for testing inventory limits, new words, potion brewing, etc.

### Resources (`resources/`)
- `definitions/`: JSON files defining adventure types, rooms, entities, actions, domains, events
- `initial_prompts/`: Jinja2 templates for game prompts (basic, plan, variants)
- `clingo_adventures2-2.py`: Main adventure generation script
- `pddl_util.py`: PDDL parsing utilities
- `pddl_to_asp.py`: Converts PDDL definitions to ASP encodings
- `new_word_generation/`: New-word action generation utilities

### PDDL/ASP Files
- `pddl_domain.lark`: Lark grammar for PDDL domain definitions
- `pddl_actions.lark`: Lark grammar for PDDL action definitions
- `pddl_events.lark`: Lark grammar for event definitions
- `adventure_solve_asp_example.lp`: Example ASP logic program for solving

### Test Files
- `test_pddl_*.txt`: PDDL parsing test cases
- `test_instances.txt`: Sample instances for validation

## Important Dependencies

Install via: `pip install -r adventuregame/requirements.txt`

- **lark==1.1.9**: Parser for PDDL and action grammars
- **clingo==5.7.1**: ASP solver for adventure generation and optimal solving
- **clemcore==3.1.0**: clemgame framework providing game infrastructure

Additional dependencies for notebooks: pandas, matplotlib, seaborn, numpy

## Instance Structure

Game instances in `in/instances.json` contain:
- `variant`: Game variant ('basic', 'plan', 'basic_invlimit', etc.)
- `prompt`: Initial prompt with goal (uses $GOAL$ placeholder)
- `initial_state`: List of PDDL-style facts defining world state
- `goal_state`: List of goal facts to achieve
- `optimal_turns`: Minimum turns to complete (from Clingo solver)
- `max_turns`: Turn limit before episode ends
- `action_definitions`: PDDL action definitions for this adventure
- `domain_definition`: PDDL domain defining types and predicates
- `event_definitions`: (Optional) PDDL event definitions for reactive world

## Metrics and Scoring

Key episode-level metrics (from `master.py:AdventureGameScorer`):
- `BENCH_SCORE`: Binary success (100 if finished, 0 otherwise)
- `achieved_goal_ratio`: Ratio of achieved goals to total goals
- `turns_over_par`: Turns taken over optimal (NaN if not finished)
- `turn_ratio`: Efficiency ratio within possible turn range
- Action failures categorized by phase (parsing/resolution) and type
- Plan following metrics (for 'plan' variant)
- Exploration metrics (epistemic/pragmatic actions, entity knowledge)

## Common Workflows

### Adding a New Adventure Type
1. Define in `resources/definitions/adventure_types.json`
2. Create room/entity/action/domain definitions in `resources/definitions/`
3. Modify `resources/clingo_adventures2-2.py` to handle new type
4. Generate adventures: `python3 clingo_adventures2-2.py`
5. Generate instances: `python3 instancegenerator.py`

### Modifying Action Definitions
1. Edit PDDL action in `resources/definitions/basic_actions_*.json`
2. Ensure grammar in `pddl_actions.lark` supports the syntax
3. Update ASP encoding in `resources/pddl_to_asp.py` if needed
4. Regenerate adventures and instances

### Debugging Failed Episodes
- Check `clembench.log` for detailed episode logs
- Use `clem_log_adv_extract.py` to extract episode data from logs
- Review action failures in episode `interactions.json` files
- Check IF interpreter state transitions in logged `goal_status` entries
